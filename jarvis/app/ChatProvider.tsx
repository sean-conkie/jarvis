"use client";

import { backendAxiosInstance } from "@/utils/backendUtils";
import { newStream } from "@/utils/streamUtils";
import {
  EventSchemas,
  EventType,
  Message,
  RunAgentInput,
  RunErrorEvent,
  TextMessageContentEvent,
  TextMessageStartEvent,
  ToolCall,
  ToolCallArgsEvent,
  ToolCallEndEvent,
  ToolCallStartEvent,
} from "@ag-ui/core";
import React, {
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { flushSync } from "react-dom";
import { v4 as uuidv4 } from "uuid";
import z from "zod";
import { ThemeArgs, useTheme } from "./_components/theme/ThemeProvider";

interface ChatContextValue {
  threadId: string | null;
  createNewChat: () => string;
  messages: Message[];
  messageEvents: Event[];
  runs: ChatRun[];
  handleSubmitMessage: (message: string, threadId: string) => Promise<void>;
}

const ChatContext = createContext<ChatContextValue | undefined>(undefined);

const RunIdResponseSchema = z.object({
  runId: z.string(),
});

type RunIdResponse = z.infer<typeof RunIdResponseSchema>;

type Event = z.infer<typeof EventSchemas>;

interface ChatProviderProps {
  children: ReactNode;
}

/**
 * Represents a call to a tool within the application, including its state and arguments.
 *
 * @property id - A unique identifier for the tool call.
 * @property name - The name of the tool being called.
 * @property state - The current state of the tool call. Can be "pending", "completed", or "failed".
 * @property arguments - Optional string containing arguments passed to the tool.
 */
export type ChatRunToolCall = {
  id: string;
  name: string;
  state:
    | EventType.TOOL_CALL_START
    | EventType.TOOL_CALL_END
    | EventType.TOOL_CALL_ARGS
    | EventType.TOOL_CALL_CHUNK;
  arguments?: string;
};

/**
 * Represents a single run within a chat thread, including its state and associated messages.
 *
 * @property id - Unique identifier for the run.
 * @property threadId - Identifier of the thread this run belongs to.
 * @property state - Current state of the run, which can be RUN_STARTED, RUN_ERROR, or RUN_FINISHED.
 * @property agentMessages - Array of messages generated by the agent during this run.
 * @property userMessage - The message sent by the user that initiated this run.
 * @property toolCalls - (Optional) Array of tool calls associated with this run.
 */
export type ChatRun = {
  id: string;
  threadId: string;
  state: EventType.RUN_STARTED | EventType.RUN_ERROR | EventType.RUN_FINISHED;
  agentMessages: Message[];
  userMessage: Message;
  toolCalls?: ChatRunToolCall[];
};

export const ChatProvider = ({ children }: ChatProviderProps) => {
  // manage the theme tool state
  const { themeTool } = useTheme();
  const themeToolRef = React.useRef(themeTool);

  // Update the ref whenever the theme tool changes
  useEffect(() => {
    themeToolRef.current = themeTool;
  }, [themeTool]);

  // State to hold the current thread ID
  const [threadId, setThreadId] = useState<string | null>(null);

  // Memoizes an object containing the current thread ID.
  const threadIdValue = useMemo(() => {
    return { threadId };
  }, [threadId]);

  // Function to create a new chat thread
  const createNewChat = useCallback((): string => {
    const newId = uuidv4();
    setThreadId(newId);
    return newId;
  }, []);

  // Use the ref to store messages prior to the current run
  // This allows us to keep track of all messages across runs
  const messagesRef = useRef<Message[]>([]);

  // State to hold message events
  const [messageEvents, setMessageEvents] = useState<Event[]>([]);

  // Memoizes an object containing the current message events.
  const messageEventsValue = useMemo(() => {
    return { messageEvents };
  }, [messageEvents]);

  // manage run state
  const [runs, setRuns] = useState<ChatRun[]>([]);
  const runsRef = useRef<ChatRun[]>(runs);
  const [runId, setRunId] = useState<string | null>(null);
  const runIdRef = useRef<string | null>(runId);

  // Memoizes an object containing the current runs.
  const runsValue = useMemo(() => {
    return { runs };
  }, [runs]);

  // State to hold messages for the current run
  // Used to store only the current run messages
  const [runMessages, setRunMessages] = useState<Message[]>([]);
  const runMessagesRef = useRef<Message[]>(runMessages);

  // Process changes in runMessages
  useEffect(() => {
    // Update the runMessagesRef whenever runMessages changes
    runMessagesRef.current = runMessages;

    // Update the run object
    if (runIdRef.current) {
      runsRef.current = runsRef.current.map((run) =>
        run.id === runIdRef.current
          ? { ...run, agentMessages: runMessagesRef.current }
          : run
      );

      // Update the runs state
      setRuns(runsRef.current);
    }
  }, [runMessages]);

  // map toolCallId to messageId
  const toolCallMapRef = useRef<Record<string, string>>({});

  // callback to get message from toolCallId
  const getMessageFromToolCallId = useCallback(
    (toolCallId: string): Message | undefined => {
      const messageId = toolCallMapRef.current[toolCallId];
      if (!messageId) {
        console.error(`Message ID not found for tool call ID: ${toolCallId}`);
        return undefined;
      }
      return runMessagesRef.current.find((msg) => msg.id === messageId);
    },
    []
  );

  // callback to get tool call from message, using toolCallId
  const getToolCall = useCallback(
    (toolCallId: string): ToolCall | undefined => {
      const message = getMessageFromToolCallId(toolCallId);
      if (!message) {
        console.error(`Message not found for tool call ID: ${toolCallId}`);
        return undefined;
      }

      if (!("toolCalls" in message)) {
        return undefined;
      }

      if (!message.toolCalls) {
        return undefined;
      }
      return message.toolCalls.find((tc) => tc.id === toolCallId);
    },
    [getMessageFromToolCallId]
  );

  // Handle submitting a message
  const handleSubmitMessage = useCallback(
    async (message: string, threadId: string) => {
      if (!threadId) {
        throw new Error("Thread ID is not defined.");
      }

      // Create a new message object
      const newMessage: Message = {
        id: uuidv4(),
        content: message,
        role: "user",
      };

      // create runIdRef
      runIdRef.current = uuidv4();
      // Update the runId state
      setRunId(runIdRef.current);

      // Create agent input
      const agentInput: RunAgentInput = {
        threadId,
        runId: runIdRef.current,
        state: {}, // Assuming state is an empty object for now
        messages: [...messagesRef.current, newMessage],
        tools: [
          {
            name: themeToolRef.current.name,
            description: themeToolRef.current.description,
            parameters: themeToolRef.current.parameters,
          },
        ],
        context: [], // Assuming no context is provided for now
        forwardedProps: "", // Assuming no forwarded props for now
      };

      console.log("Submitting message:", agentInput);

      // set the runMessages state
      setRunMessages([]);

      // Submit the message
      try {
        // 1. Trigger the process via POST (using fetch or axios)
        const res = await backendAxiosInstance.post<RunIdResponse>(
          "/chat/start",
          agentInput
        );

        const validated = RunIdResponseSchema.safeParse(res.data);
        if (!validated.success) {
          console.error("Validation failed:", validated.error.errors);
          return;
        }

        const { runId } = validated.data;

        // 2. Subscribe to the SSE stream
        const eventSource = newStream(`/chat/stream/${runId}`);

        eventSource.onmessage = async (event) => {
          const validated = EventSchemas.safeParse(JSON.parse(event.data));
          if (!validated.success) {
            console.error("Validation failed:", validated.error.errors);
            eventSource.close();
            return;
          }

          setMessageEvents((prevEvents) => [...prevEvents, validated.data]);

          // if the event is message start, set the messageId
          if (validated.data.type === EventType.TEXT_MESSAGE_START) {
            const message = validated.data as TextMessageStartEvent;

            // if the message already exists, do not create a new one
            const existingMessage = runMessagesRef.current.find(
              (msg) => msg.id === message.messageId
            );

            if (existingMessage) {
              // If the message already exists, just return
              return;
            }

            // If the event is a message start, create a new message object
            const newEventMessage: Message = {
              id: message.messageId || uuidv4(),
              content: "",
              role: message.role || "assistant",
              toolCalls: [],
            };

            // Add the new message to the runMessagesRef
            runMessagesRef.current = [
              ...runMessagesRef.current,
              newEventMessage,
            ];

            // Add the new message to the messages state
            flushSync(() => {
              setRunMessages((prevMessages) => [
                ...prevMessages,
                newEventMessage,
              ]);
            });
          } else if (validated.data.type === EventType.TOOL_CALL_START) {
            const toolCallEvent = validated.data as ToolCallStartEvent;

            // is there a parentMessageId?
            const parentMessageId = toolCallEvent.parentMessageId || uuidv4();
            let parentMessage: Message | undefined =
              runMessagesRef.current.find((msg) => msg.id === parentMessageId);

            if (parentMessage === undefined) {
              // create a new parent message if it doesn't exist
              const newParentMessage: Message = {
                id: parentMessageId,
                content: undefined,
                role: "assistant",
                toolCalls: [],
              };

              // Add the new parent message to the runMessagesRef
              runMessagesRef.current = [
                ...runMessagesRef.current,
                newParentMessage,
              ];

              // Add the new parent message to the runMessages state
              flushSync(() => {
                setRunMessages((prevMessages) => [
                  ...prevMessages,
                  newParentMessage,
                ]);
              });
              parentMessage = newParentMessage;
            }

            if (!("toolCalls" in parentMessage)) {
              parentMessage = {
                ...parentMessage,
                role: "assistant",
                toolCalls: [] as ToolCall[],
              };
            }

            // create the tool call
            const toolCall: ToolCall = {
              id: toolCallEvent.toolCallId || uuidv4(),
              type: "function",
              function: {
                name: toolCallEvent.toolCallName,
                arguments: "",
              },
            };

            // Add the tool call to the parent message's toolCalls array
            parentMessage.toolCalls!.push(toolCall);

            // Update the toolCallId to messageId map
            toolCallMapRef.current[toolCallEvent.toolCallId] = parentMessage.id;

            // Update the runMessagesRef with the new parent message
            runMessagesRef.current = runMessagesRef.current.map((msg) =>
              msg.id === parentMessageId ? parentMessage : msg
            );

            // create a tool call object and add it to the run state
            const runToolCall = {
              id: toolCall.id,
              name: toolCall.function.name,
              state: toolCallEvent.type,
              arguments: toolCall.function.arguments,
            };
            const currentRun = runsRef.current.find(
              (run) => run.id === runIdRef.current
            );
            if (currentRun) {
              if (!("toolCalls" in currentRun)) {
                currentRun.toolCalls = [];
              }
              currentRun.toolCalls!.push(runToolCall);
            }

            // Update the runsRef with the new run
            runsRef.current = runsRef.current.map((run) =>
              run.id === runIdRef.current ? currentRun! : run
            );

            // Update the runs state
            flushSync(() => {
              setRuns(runsRef.current);
            });
          } else if (validated.data.type === EventType.TEXT_MESSAGE_CONTENT) {
            // If the event is a message content, append it to the existing message
            const message = validated.data as TextMessageContentEvent;
            if (message.messageId) {
              // Update the message content in the runMessagesRef
              runMessagesRef.current = runMessagesRef.current.map((msg) => {
                if (msg.id === message.messageId) {
                  return {
                    ...msg,
                    content: message.delta,
                  };
                }
                return msg;
              });

              flushSync(() => {
                setRunMessages((prevMessages) =>
                  prevMessages.map((msg) =>
                    msg.id === message.messageId
                      ? {
                          ...msg,
                          content: message.delta,
                        }
                      : msg
                  )
                );
              });
            }
          } else if (validated.data.type === EventType.TOOL_CALL_ARGS) {
            const toolCallArgs = validated.data as ToolCallArgsEvent;
            const message = getMessageFromToolCallId(toolCallArgs.toolCallId);
            const toolCall = getToolCall(toolCallArgs.toolCallId);

            if (!message) {
              // If the message is not found, log an error and return
              console.error(
                `Message not found for tool call ID: ${toolCallArgs.toolCallId}`
              );
              return;
            }

            // If the tool call is not found, log an error and return
            if (!toolCall) {
              console.error(
                `Tool call not found for tool call ID: ${toolCallArgs.toolCallId}`
              );
              return;
            }

            if (toolCall && message && "toolCalls" in message) {
              toolCall.function.arguments = toolCallArgs.delta;

              // Update the tool call in the message's toolCalls array
              message.toolCalls = message.toolCalls!.map((tc) =>
                tc.id === toolCall.id ? toolCall : tc
              );

              // update the message ref with the updated message
              runMessagesRef.current = runMessagesRef.current.map((msg) =>
                msg.id === message.id ? message : msg
              );

              // Update the tool call in the message's toolCalls array
              flushSync(() => {
                setRunMessages((prevMessages) =>
                  prevMessages.map((msg) =>
                    msg.id === message.id ? message : msg
                  )
                );
              });

              // Update the runsRef with the updated run
              const updatedRefs = runsRef.current.map((run) => {
                if (run.id === runIdRef.current) {
                  // Find the tool call in the run's toolCalls array
                  const runToolCall = run.toolCalls?.find(
                    (tc) => tc.id === toolCall.id
                  );

                  if (runToolCall) {
                    // Update the tool call arguments and state
                    runToolCall.arguments = toolCall.function.arguments;
                    runToolCall.state = EventType.TOOL_CALL_ARGS;
                    run.toolCalls = run.toolCalls?.map((tc) =>
                      tc.id === toolCall.id ? runToolCall : tc
                    );
                  } else {
                    // If the tool call is not found, add it to the run's toolCalls array
                    run.toolCalls?.push({
                      id: toolCall.id,
                      name: toolCall.function.name,
                      state: EventType.TOOL_CALL_ARGS,
                      arguments: toolCall.function.arguments,
                    });
                  }
                }
                return run;
              });
              runsRef.current = updatedRefs;

              // Update the runs state
              flushSync(() => {
                setRuns(runsRef.current);
              });
            }
          } else if (validated.data.type === EventType.TOOL_CALL_END) {
            // run the tool call and add the response to the messages
            const toolCallEnd = validated.data as ToolCallEndEvent;
            const toolCall = getToolCall(toolCallEnd.toolCallId);

            if (toolCall) {
              // Assuming the tool call response is in toolCallEnd.result
              let toolCallArgs: Record<string, unknown> | undefined = undefined;
              try {
                toolCallArgs = JSON.parse(toolCall.function.arguments);
              } catch (error) {
                console.debug("Failed to parse tool call arguments:", error);
                toolCallArgs = {};
              }

              let result: string | undefined = undefined;
              if (toolCall.function.name === "setTheme") {
                if (toolCallArgs) {
                  result = JSON.stringify(
                    await themeToolRef.current.invoke(
                      toolCallArgs as unknown as ThemeArgs
                    )
                  );
                } else {
                  console.error(
                    "Tool call arguments are undefined or invalid."
                  );
                }
              }

              const toolResultMessage: Message = {
                id: uuidv4(),
                toolCallId: toolCall.id,
                content: result || "",
                role: "tool",
              };

              // Add the tool result message to the runMessagesRef
              runMessagesRef.current = [
                ...runMessagesRef.current,
                toolResultMessage,
              ];

              flushSync(() => {
                setRunMessages((prevMessages) => [
                  ...prevMessages,
                  toolResultMessage,
                ]);
              });

              // Update the runsRef with the updated run
              const updatedRefs = runsRef.current.map((run) => {
                if (run.id === runIdRef.current) {
                  // Find the tool call in the run's toolCalls array
                  const runToolCall = run.toolCalls?.find(
                    (tc) => tc.id === toolCall.id
                  );

                  if (runToolCall) {
                    // Update the tool call arguments and state
                    runToolCall.state = EventType.TOOL_CALL_END;
                    run.toolCalls = run.toolCalls?.map((tc) =>
                      tc.id === toolCall.id ? runToolCall : tc
                    );
                  } else {
                    // If the tool call is not found, add it to the run's toolCalls array
                    run.toolCalls?.push({
                      id: toolCall.id,
                      name: toolCall.function.name,
                      state: EventType.TOOL_CALL_END,
                      arguments: toolCall.function.arguments,
                    });
                  }
                }
                return run;
              });
              runsRef.current = updatedRefs;

              // Update the runs state
              flushSync(() => {
                setRuns(runsRef.current);
              });
            }
          } else if (validated.data.type === EventType.TEXT_MESSAGE_END) {
          } else if (validated.data.type === EventType.RUN_ERROR) {
            // If the event is a run error, log the error and close the event source
            // If the run is finished, update the run state
            const runErrorEvent = validated.data as RunErrorEvent;
            runsRef.current = runsRef.current.map((run) =>
              run.id === runIdRef.current
                ? {
                    ...run,
                    state: runErrorEvent.type,
                  }
                : run
            );

            // Update the runs state
            flushSync(() => {
              setRuns(runsRef.current);
            });
            console.error("Run error:", runErrorEvent.message);
            eventSource.close();
            return;
          } else if (validated.data.type === EventType.RUN_STARTED) {
            // Create the run object
            const newRun: ChatRun = {
              id: agentInput.runId,
              threadId: agentInput.threadId,
              state: EventType.RUN_STARTED,
              agentMessages: [],
              userMessage: newMessage,
            };
            // Add the new run to the runsRef
            runsRef.current = [...runsRef.current, newRun];

            // Update the runs state
            flushSync(() => {
              setRuns((prevRuns) => [...prevRuns, newRun]);
            });
          } else if (validated.data.type === EventType.RUN_FINISHED) {
            // If the run is finished, update the run state
            const runFinishedEvent = validated.data;
            runsRef.current = runsRef.current.map((run) =>
              run.id === runFinishedEvent.runId
                ? {
                    ...run,
                    state: runFinishedEvent.type,
                  }
                : run
            );

            // Update the runs state
            flushSync(() => {
              setRuns(runsRef.current);
            });

            const currentRun = runsRef.current.find(
              (run) => run.id === runIdRef.current
            );
            if (currentRun) {
              // Update the messagesRef with the final messages
              console.log("Updating messagesRef with current run messages");
              messagesRef.current = [
                ...messagesRef.current,
                currentRun.userMessage,
                ...runMessagesRef.current,
              ];
              console.log("Updated messagesRef:", messagesRef.current);
            }

            eventSource.close();
            return;
          }
        };

        eventSource.onerror = (err) => {
          // If the run is RUN_STARTED, update the run state to RUN_ERROR
          if (runIdRef.current) {
            const currentRun = runsRef.current.find(
              (run) => run.id === runIdRef.current
            );
            if (currentRun && currentRun.state === EventType.RUN_STARTED) {
              runsRef.current = runsRef.current.map((run) =>
                run.id === runIdRef.current
                  ? { ...run, state: EventType.RUN_ERROR }
                  : run
              );
              // Update the runs state
              flushSync(() => {
                setRuns(runsRef.current);
              });
            }
          }
          console.error("EventSource failed:", err);
          eventSource.close();
        };
      } catch {
        console.error("Something went wrong with chat 😔");
      }
    },
    [getMessageFromToolCallId, getToolCall]
  );

  return (
    <ChatContext.Provider
      value={{
        ...threadIdValue,
        createNewChat,
        messages: messagesRef.current,
        ...messageEventsValue,
        ...runsValue,
        handleSubmitMessage,
      }}
    >
      {children}
    </ChatContext.Provider>
  );
};

export const useChat = (): ChatContextValue => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error("useChat must be used within a ChatProvider");
  }
  return context;
};
